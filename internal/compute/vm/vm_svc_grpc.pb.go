// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: svc/compute/vm/vm_svc.proto

package vm

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VMService_CountVMs_FullMethodName                  = "/org.cudo.compute.v1.VMService/CountVMs"
	VMService_CreateVM_FullMethodName                  = "/org.cudo.compute.v1.VMService/CreateVM"
	VMService_GetVM_FullMethodName                     = "/org.cudo.compute.v1.VMService/GetVM"
	VMService_ListVMs_FullMethodName                   = "/org.cudo.compute.v1.VMService/ListVMs"
	VMService_MonitorVM_FullMethodName                 = "/org.cudo.compute.v1.VMService/MonitorVM"
	VMService_RebootVM_FullMethodName                  = "/org.cudo.compute.v1.VMService/RebootVM"
	VMService_StartVM_FullMethodName                   = "/org.cudo.compute.v1.VMService/StartVM"
	VMService_StopVM_FullMethodName                    = "/org.cudo.compute.v1.VMService/StopVM"
	VMService_TerminateVM_FullMethodName               = "/org.cudo.compute.v1.VMService/TerminateVM"
	VMService_ConnectVM_FullMethodName                 = "/org.cudo.compute.v1.VMService/ConnectVM"
	VMService_ResizeVM_FullMethodName                  = "/org.cudo.compute.v1.VMService/ResizeVM"
	VMService_ListPublicVMImages_FullMethodName        = "/org.cudo.compute.v1.VMService/ListPublicVMImages"
	VMService_ListVMMachineTypes_FullMethodName        = "/org.cudo.compute.v1.VMService/ListVMMachineTypes"
	VMService_ListVMMachineTypes2_FullMethodName       = "/org.cudo.compute.v1.VMService/ListVMMachineTypes2"
	VMService_ListVMDataCenters_FullMethodName         = "/org.cudo.compute.v1.VMService/ListVMDataCenters"
	VMService_ListVMGpuModels_FullMethodName           = "/org.cudo.compute.v1.VMService/ListVMGpuModels"
	VMService_CreatePrivateVMImage_FullMethodName      = "/org.cudo.compute.v1.VMService/CreatePrivateVMImage"
	VMService_DeletePrivateVMImage_FullMethodName      = "/org.cudo.compute.v1.VMService/DeletePrivateVMImage"
	VMService_GetPrivateVMImage_FullMethodName         = "/org.cudo.compute.v1.VMService/GetPrivateVMImage"
	VMService_ListPrivateVMImages_FullMethodName       = "/org.cudo.compute.v1.VMService/ListPrivateVMImages"
	VMService_UpdatePrivateVMImage_FullMethodName      = "/org.cudo.compute.v1.VMService/UpdatePrivateVMImage"
	VMService_CreateStorageDisk_FullMethodName         = "/org.cudo.compute.v1.VMService/CreateStorageDisk"
	VMService_ResizeVMDisk_FullMethodName              = "/org.cudo.compute.v1.VMService/ResizeVMDisk"
	VMService_ListDisks_FullMethodName                 = "/org.cudo.compute.v1.VMService/ListDisks"
	VMService_GetDisk_FullMethodName                   = "/org.cudo.compute.v1.VMService/GetDisk"
	VMService_DeleteStorageDisk_FullMethodName         = "/org.cudo.compute.v1.VMService/DeleteStorageDisk"
	VMService_AttachStorageDisk_FullMethodName         = "/org.cudo.compute.v1.VMService/AttachStorageDisk"
	VMService_DetachStorageDisk_FullMethodName         = "/org.cudo.compute.v1.VMService/DetachStorageDisk"
	VMService_AttachSecurityGroup_FullMethodName       = "/org.cudo.compute.v1.VMService/AttachSecurityGroup"
	VMService_DetachSecurityGroup_FullMethodName       = "/org.cudo.compute.v1.VMService/DetachSecurityGroup"
	VMService_UpdateVMMetadata_FullMethodName          = "/org.cudo.compute.v1.VMService/UpdateVMMetadata"
	VMService_UpdateVMExpireTime_FullMethodName        = "/org.cudo.compute.v1.VMService/UpdateVMExpireTime"
	VMService_UpdateVMPassword_FullMethodName          = "/org.cudo.compute.v1.VMService/UpdateVMPassword"
	VMService_UpdateVMAuthorizedSSHKeys_FullMethodName = "/org.cudo.compute.v1.VMService/UpdateVMAuthorizedSSHKeys"
	VMService_CommitVM_FullMethodName                  = "/org.cudo.compute.v1.VMService/CommitVM"
	VMService_GetVMMachineType_FullMethodName          = "/org.cudo.compute.v1.VMService/GetVMMachineType"
)

// VMServiceClient is the client API for VMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VMServiceClient interface {
	// Count virtual machines in a project
	//
	// Returns the total number of virtual machines in a project.
	CountVMs(ctx context.Context, in *CountVMsRequest, opts ...grpc.CallOption) (*CountVMsResponse, error)
	// Create a virtual machine
	//
	// Creates and starts a new virtual machine.
	CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*CreateVMResponse, error)
	// Get a virtual machine
	//
	// Retrieves the details of a virtual machine.
	GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error)
	// List virtual machines
	//
	// Lists all virtual machines in a project.
	ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error)
	// Monitor a virtual machine
	//
	// Returns live monitoring metrics for a virtual machine.
	MonitorVM(ctx context.Context, in *MonitorVMRequest, opts ...grpc.CallOption) (*MonitorVMResponse, error)
	// Reboot a virtual machine
	//
	// Performs a soft reboot of a virtual machine. The operating system is instructed to reboot. If the OS does not respond, use StopVM and then StartVM.
	RebootVM(ctx context.Context, in *RebootVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Start a virtual machine
	//
	// Starts a stopped virtual machine.
	StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Stop a virtual machine
	//
	// Stops a running virtual machine. The virtual machine can be started again later.
	StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Delete a virtual machine
	//
	// Permanently deletes a virtual machine. All data on the virtual machine's boot disk will be lost. Any attached storage disks will be detached but not deleted.
	TerminateVM(ctx context.Context, in *TerminateVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Connect to a virtual machine
	//
	// Provides a URL and token to connect to the virtual machine via a web-based VNC console.
	ConnectVM(ctx context.Context, in *ConnectVMRequest, opts ...grpc.CallOption) (*ConnectVMResponse, error)
	// Resize a virtual machine
	//
	// Resizes a virtual machine. The size of the virtual machine cannot be reduced while it is in a committed term.
	ResizeVM(ctx context.Context, in *ResizeVMRequest, opts ...grpc.CallOption) (*ResizeVMResponse, error)
	// List public virtual machine images
	//
	// Lists all public images available for virtual machines.
	ListPublicVMImages(ctx context.Context, in *ListPublicVMImagesRequest, opts ...grpc.CallOption) (*ListPublicVMImagesResponse, error)
	// List virtual machine types
	//
	// Lists all virtual machine types available.
	ListVMMachineTypes(ctx context.Context, in *ListVMMachineTypesRequest, opts ...grpc.CallOption) (*ListVMMachineTypesResponse, error)
	// Lists virtual machine types (deprecated)
	//
	// Lists all virtual machine types available.
	ListVMMachineTypes2(ctx context.Context, in *ListVMMachineTypesRequest, opts ...grpc.CallOption) (*ListVMMachineTypesResponse, error)
	// List virtual machine data centers
	//
	// Lists all data centers available for virtual machines.
	ListVMDataCenters(ctx context.Context, in *ListVMDataCentersRequest, opts ...grpc.CallOption) (*ListVMDataCentersResponse, error)
	// List virtual machine GPU models
	//
	// Lists all GPU models available for virtual machines.
	ListVMGpuModels(ctx context.Context, in *ListVMGpuModelsRequest, opts ...grpc.CallOption) (*ListVMGpuModelsResponse, error)
	// Create a private virtual machine image
	//
	// Creates a new private virtual machine image from an existing virtual machine's boot disk.
	CreatePrivateVMImage(ctx context.Context, in *CreatePrivateVMImageRequest, opts ...grpc.CallOption) (*CreatePrivateVMImageResponse, error)
	// Delete a private virtual machine image
	//
	// Deletes a private virtual machine image.
	DeletePrivateVMImage(ctx context.Context, in *DeletePrivateVMImageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get a private virtual machine image
	//
	// Retrieves the details of a private virtual machine image.
	GetPrivateVMImage(ctx context.Context, in *GetPrivateVMImageRequest, opts ...grpc.CallOption) (*GetPrivateVMImageResponse, error)
	// List private virtual machine images
	//
	// Lists private virtual machine images in a project.
	ListPrivateVMImages(ctx context.Context, in *ListPrivateVMImagesRequest, opts ...grpc.CallOption) (*ListPrivateVMImagesResponse, error)
	// Update a private virtual machine image
	//
	// Updates the description of a private virtual machine image.
	UpdatePrivateVMImage(ctx context.Context, in *UpdatePrivateVMImageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Create a disk
	//
	// Creates a new virtual machine disk.
	CreateStorageDisk(ctx context.Context, in *CreateStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Resize a virtual machine disk
	//
	// Resizes a disk attached to a virtual machine. The new size must be larger than the current size.
	ResizeVMDisk(ctx context.Context, in *ResizeVMDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// List disks
	//
	// Lists virtual machine disks in a project.
	ListDisks(ctx context.Context, in *ListDisksRequest, opts ...grpc.CallOption) (*ListDisksResponse, error)
	// Get a disk
	//
	// Retrieves the details of a virtual machine disk.
	GetDisk(ctx context.Context, in *GetDiskRequest, opts ...grpc.CallOption) (*GetDiskResponse, error)
	// Delete a disk
	//
	// Deletes a virtual machine disk. The disk must be detached from any virtual machines before it can be deleted.
	DeleteStorageDisk(ctx context.Context, in *DeleteStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Attach a disk to a virtual machine
	//
	// Attaches a virtual machine disk to a virtual machine.
	AttachStorageDisk(ctx context.Context, in *AttachStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Detach a disk from a virtual machine
	//
	// Detaches a virtual machine disk from a virtual machine.
	DetachStorageDisk(ctx context.Context, in *DetachStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Attach a security group to a virtual machine
	//
	// Attaches a security group to a virtual machine.
	AttachSecurityGroup(ctx context.Context, in *AttachSecurityGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Detach a security group from a virtual machine
	//
	// Detaches a security group from a virtual machine.
	DetachSecurityGroup(ctx context.Context, in *DetachSecurityGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Update virtual machine metadata
	//
	// Updates the metadata of a virtual machine.
	UpdateVMMetadata(ctx context.Context, in *UpdateVMMetadataRequest, opts ...grpc.CallOption) (*UpdateVMMetadataResponse, error)
	// Update virtual machine expiration time
	//
	// Updates the expiration time of a virtual machine. The virtual machine will be automatically deleted when it reaches its expiration time.
	UpdateVMExpireTime(ctx context.Context, in *UpdateVMExpireTimeRequest, opts ...grpc.CallOption) (*UpdateVMExpireTimeResponse, error)
	// Update virtual machine password
	//
	// Updates the root or administrator password of a virtual machine.
	UpdateVMPassword(ctx context.Context, in *UpdateVMPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Update virtual machine authorized SSH keys
	//
	// Updates the authorized SSH keys of a virtual machine.
	UpdateVMAuthorizedSSHKeys(ctx context.Context, in *UpdateVMAuthorizedSSHKeysRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Purchase a commitment for a virtual machine
	//
	// Commits a virtual machine to a longer-term plan in exchange for a lower hourly rate. The virtual machine must not already be in a committed term.
	CommitVM(ctx context.Context, in *CommitVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get a virtual machine type
	//
	// Retrieves the details of a virtual machine type.
	GetVMMachineType(ctx context.Context, in *GetVMMachineTypeRequest, opts ...grpc.CallOption) (*GetVMMachineTypeResponse, error)
}

type vMServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVMServiceClient(cc grpc.ClientConnInterface) VMServiceClient {
	return &vMServiceClient{cc}
}

func (c *vMServiceClient) CountVMs(ctx context.Context, in *CountVMsRequest, opts ...grpc.CallOption) (*CountVMsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountVMsResponse)
	err := c.cc.Invoke(ctx, VMService_CountVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CreateVM(ctx context.Context, in *CreateVMRequest, opts ...grpc.CallOption) (*CreateVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVMResponse)
	err := c.cc.Invoke(ctx, VMService_CreateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVMResponse)
	err := c.cc.Invoke(ctx, VMService_GetVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMsResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) MonitorVM(ctx context.Context, in *MonitorVMRequest, opts ...grpc.CallOption) (*MonitorVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MonitorVMResponse)
	err := c.cc.Invoke(ctx, VMService_MonitorVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) RebootVM(ctx context.Context, in *RebootVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_RebootVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StartVM(ctx context.Context, in *StartVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_StartVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StopVM(ctx context.Context, in *StopVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_StopVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) TerminateVM(ctx context.Context, in *TerminateVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_TerminateVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ConnectVM(ctx context.Context, in *ConnectVMRequest, opts ...grpc.CallOption) (*ConnectVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectVMResponse)
	err := c.cc.Invoke(ctx, VMService_ConnectVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ResizeVM(ctx context.Context, in *ResizeVMRequest, opts ...grpc.CallOption) (*ResizeVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResizeVMResponse)
	err := c.cc.Invoke(ctx, VMService_ResizeVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListPublicVMImages(ctx context.Context, in *ListPublicVMImagesRequest, opts ...grpc.CallOption) (*ListPublicVMImagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPublicVMImagesResponse)
	err := c.cc.Invoke(ctx, VMService_ListPublicVMImages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMMachineTypes(ctx context.Context, in *ListVMMachineTypesRequest, opts ...grpc.CallOption) (*ListVMMachineTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMMachineTypesResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMMachineTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMMachineTypes2(ctx context.Context, in *ListVMMachineTypesRequest, opts ...grpc.CallOption) (*ListVMMachineTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMMachineTypesResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMMachineTypes2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMDataCenters(ctx context.Context, in *ListVMDataCentersRequest, opts ...grpc.CallOption) (*ListVMDataCentersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMDataCentersResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMDataCenters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListVMGpuModels(ctx context.Context, in *ListVMGpuModelsRequest, opts ...grpc.CallOption) (*ListVMGpuModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMGpuModelsResponse)
	err := c.cc.Invoke(ctx, VMService_ListVMGpuModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CreatePrivateVMImage(ctx context.Context, in *CreatePrivateVMImageRequest, opts ...grpc.CallOption) (*CreatePrivateVMImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePrivateVMImageResponse)
	err := c.cc.Invoke(ctx, VMService_CreatePrivateVMImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DeletePrivateVMImage(ctx context.Context, in *DeletePrivateVMImageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DeletePrivateVMImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetPrivateVMImage(ctx context.Context, in *GetPrivateVMImageRequest, opts ...grpc.CallOption) (*GetPrivateVMImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrivateVMImageResponse)
	err := c.cc.Invoke(ctx, VMService_GetPrivateVMImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListPrivateVMImages(ctx context.Context, in *ListPrivateVMImagesRequest, opts ...grpc.CallOption) (*ListPrivateVMImagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPrivateVMImagesResponse)
	err := c.cc.Invoke(ctx, VMService_ListPrivateVMImages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) UpdatePrivateVMImage(ctx context.Context, in *UpdatePrivateVMImageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_UpdatePrivateVMImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CreateStorageDisk(ctx context.Context, in *CreateStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_CreateStorageDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ResizeVMDisk(ctx context.Context, in *ResizeVMDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_ResizeVMDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ListDisks(ctx context.Context, in *ListDisksRequest, opts ...grpc.CallOption) (*ListDisksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDisksResponse)
	err := c.cc.Invoke(ctx, VMService_ListDisks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetDisk(ctx context.Context, in *GetDiskRequest, opts ...grpc.CallOption) (*GetDiskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDiskResponse)
	err := c.cc.Invoke(ctx, VMService_GetDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DeleteStorageDisk(ctx context.Context, in *DeleteStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DeleteStorageDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) AttachStorageDisk(ctx context.Context, in *AttachStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_AttachStorageDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DetachStorageDisk(ctx context.Context, in *DetachStorageDiskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DetachStorageDisk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) AttachSecurityGroup(ctx context.Context, in *AttachSecurityGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_AttachSecurityGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DetachSecurityGroup(ctx context.Context, in *DetachSecurityGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_DetachSecurityGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) UpdateVMMetadata(ctx context.Context, in *UpdateVMMetadataRequest, opts ...grpc.CallOption) (*UpdateVMMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateVMMetadataResponse)
	err := c.cc.Invoke(ctx, VMService_UpdateVMMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) UpdateVMExpireTime(ctx context.Context, in *UpdateVMExpireTimeRequest, opts ...grpc.CallOption) (*UpdateVMExpireTimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateVMExpireTimeResponse)
	err := c.cc.Invoke(ctx, VMService_UpdateVMExpireTime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) UpdateVMPassword(ctx context.Context, in *UpdateVMPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_UpdateVMPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) UpdateVMAuthorizedSSHKeys(ctx context.Context, in *UpdateVMAuthorizedSSHKeysRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_UpdateVMAuthorizedSSHKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) CommitVM(ctx context.Context, in *CommitVMRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VMService_CommitVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetVMMachineType(ctx context.Context, in *GetVMMachineTypeRequest, opts ...grpc.CallOption) (*GetVMMachineTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVMMachineTypeResponse)
	err := c.cc.Invoke(ctx, VMService_GetVMMachineType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VMServiceServer is the server API for VMService service.
// All implementations must embed UnimplementedVMServiceServer
// for forward compatibility.
type VMServiceServer interface {
	// Count virtual machines in a project
	//
	// Returns the total number of virtual machines in a project.
	CountVMs(context.Context, *CountVMsRequest) (*CountVMsResponse, error)
	// Create a virtual machine
	//
	// Creates and starts a new virtual machine.
	CreateVM(context.Context, *CreateVMRequest) (*CreateVMResponse, error)
	// Get a virtual machine
	//
	// Retrieves the details of a virtual machine.
	GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error)
	// List virtual machines
	//
	// Lists all virtual machines in a project.
	ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error)
	// Monitor a virtual machine
	//
	// Returns live monitoring metrics for a virtual machine.
	MonitorVM(context.Context, *MonitorVMRequest) (*MonitorVMResponse, error)
	// Reboot a virtual machine
	//
	// Performs a soft reboot of a virtual machine. The operating system is instructed to reboot. If the OS does not respond, use StopVM and then StartVM.
	RebootVM(context.Context, *RebootVMRequest) (*emptypb.Empty, error)
	// Start a virtual machine
	//
	// Starts a stopped virtual machine.
	StartVM(context.Context, *StartVMRequest) (*emptypb.Empty, error)
	// Stop a virtual machine
	//
	// Stops a running virtual machine. The virtual machine can be started again later.
	StopVM(context.Context, *StopVMRequest) (*emptypb.Empty, error)
	// Delete a virtual machine
	//
	// Permanently deletes a virtual machine. All data on the virtual machine's boot disk will be lost. Any attached storage disks will be detached but not deleted.
	TerminateVM(context.Context, *TerminateVMRequest) (*emptypb.Empty, error)
	// Connect to a virtual machine
	//
	// Provides a URL and token to connect to the virtual machine via a web-based VNC console.
	ConnectVM(context.Context, *ConnectVMRequest) (*ConnectVMResponse, error)
	// Resize a virtual machine
	//
	// Resizes a virtual machine. The size of the virtual machine cannot be reduced while it is in a committed term.
	ResizeVM(context.Context, *ResizeVMRequest) (*ResizeVMResponse, error)
	// List public virtual machine images
	//
	// Lists all public images available for virtual machines.
	ListPublicVMImages(context.Context, *ListPublicVMImagesRequest) (*ListPublicVMImagesResponse, error)
	// List virtual machine types
	//
	// Lists all virtual machine types available.
	ListVMMachineTypes(context.Context, *ListVMMachineTypesRequest) (*ListVMMachineTypesResponse, error)
	// Lists virtual machine types (deprecated)
	//
	// Lists all virtual machine types available.
	ListVMMachineTypes2(context.Context, *ListVMMachineTypesRequest) (*ListVMMachineTypesResponse, error)
	// List virtual machine data centers
	//
	// Lists all data centers available for virtual machines.
	ListVMDataCenters(context.Context, *ListVMDataCentersRequest) (*ListVMDataCentersResponse, error)
	// List virtual machine GPU models
	//
	// Lists all GPU models available for virtual machines.
	ListVMGpuModels(context.Context, *ListVMGpuModelsRequest) (*ListVMGpuModelsResponse, error)
	// Create a private virtual machine image
	//
	// Creates a new private virtual machine image from an existing virtual machine's boot disk.
	CreatePrivateVMImage(context.Context, *CreatePrivateVMImageRequest) (*CreatePrivateVMImageResponse, error)
	// Delete a private virtual machine image
	//
	// Deletes a private virtual machine image.
	DeletePrivateVMImage(context.Context, *DeletePrivateVMImageRequest) (*emptypb.Empty, error)
	// Get a private virtual machine image
	//
	// Retrieves the details of a private virtual machine image.
	GetPrivateVMImage(context.Context, *GetPrivateVMImageRequest) (*GetPrivateVMImageResponse, error)
	// List private virtual machine images
	//
	// Lists private virtual machine images in a project.
	ListPrivateVMImages(context.Context, *ListPrivateVMImagesRequest) (*ListPrivateVMImagesResponse, error)
	// Update a private virtual machine image
	//
	// Updates the description of a private virtual machine image.
	UpdatePrivateVMImage(context.Context, *UpdatePrivateVMImageRequest) (*emptypb.Empty, error)
	// Create a disk
	//
	// Creates a new virtual machine disk.
	CreateStorageDisk(context.Context, *CreateStorageDiskRequest) (*emptypb.Empty, error)
	// Resize a virtual machine disk
	//
	// Resizes a disk attached to a virtual machine. The new size must be larger than the current size.
	ResizeVMDisk(context.Context, *ResizeVMDiskRequest) (*emptypb.Empty, error)
	// List disks
	//
	// Lists virtual machine disks in a project.
	ListDisks(context.Context, *ListDisksRequest) (*ListDisksResponse, error)
	// Get a disk
	//
	// Retrieves the details of a virtual machine disk.
	GetDisk(context.Context, *GetDiskRequest) (*GetDiskResponse, error)
	// Delete a disk
	//
	// Deletes a virtual machine disk. The disk must be detached from any virtual machines before it can be deleted.
	DeleteStorageDisk(context.Context, *DeleteStorageDiskRequest) (*emptypb.Empty, error)
	// Attach a disk to a virtual machine
	//
	// Attaches a virtual machine disk to a virtual machine.
	AttachStorageDisk(context.Context, *AttachStorageDiskRequest) (*emptypb.Empty, error)
	// Detach a disk from a virtual machine
	//
	// Detaches a virtual machine disk from a virtual machine.
	DetachStorageDisk(context.Context, *DetachStorageDiskRequest) (*emptypb.Empty, error)
	// Attach a security group to a virtual machine
	//
	// Attaches a security group to a virtual machine.
	AttachSecurityGroup(context.Context, *AttachSecurityGroupRequest) (*emptypb.Empty, error)
	// Detach a security group from a virtual machine
	//
	// Detaches a security group from a virtual machine.
	DetachSecurityGroup(context.Context, *DetachSecurityGroupRequest) (*emptypb.Empty, error)
	// Update virtual machine metadata
	//
	// Updates the metadata of a virtual machine.
	UpdateVMMetadata(context.Context, *UpdateVMMetadataRequest) (*UpdateVMMetadataResponse, error)
	// Update virtual machine expiration time
	//
	// Updates the expiration time of a virtual machine. The virtual machine will be automatically deleted when it reaches its expiration time.
	UpdateVMExpireTime(context.Context, *UpdateVMExpireTimeRequest) (*UpdateVMExpireTimeResponse, error)
	// Update virtual machine password
	//
	// Updates the root or administrator password of a virtual machine.
	UpdateVMPassword(context.Context, *UpdateVMPasswordRequest) (*emptypb.Empty, error)
	// Update virtual machine authorized SSH keys
	//
	// Updates the authorized SSH keys of a virtual machine.
	UpdateVMAuthorizedSSHKeys(context.Context, *UpdateVMAuthorizedSSHKeysRequest) (*emptypb.Empty, error)
	// Purchase a commitment for a virtual machine
	//
	// Commits a virtual machine to a longer-term plan in exchange for a lower hourly rate. The virtual machine must not already be in a committed term.
	CommitVM(context.Context, *CommitVMRequest) (*emptypb.Empty, error)
	// Get a virtual machine type
	//
	// Retrieves the details of a virtual machine type.
	GetVMMachineType(context.Context, *GetVMMachineTypeRequest) (*GetVMMachineTypeResponse, error)
	mustEmbedUnimplementedVMServiceServer()
}

// UnimplementedVMServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVMServiceServer struct{}

func (UnimplementedVMServiceServer) CountVMs(context.Context, *CountVMsRequest) (*CountVMsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountVMs not implemented")
}
func (UnimplementedVMServiceServer) CreateVM(context.Context, *CreateVMRequest) (*CreateVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVM not implemented")
}
func (UnimplementedVMServiceServer) GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVM not implemented")
}
func (UnimplementedVMServiceServer) ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedVMServiceServer) MonitorVM(context.Context, *MonitorVMRequest) (*MonitorVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MonitorVM not implemented")
}
func (UnimplementedVMServiceServer) RebootVM(context.Context, *RebootVMRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebootVM not implemented")
}
func (UnimplementedVMServiceServer) StartVM(context.Context, *StartVMRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartVM not implemented")
}
func (UnimplementedVMServiceServer) StopVM(context.Context, *StopVMRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopVM not implemented")
}
func (UnimplementedVMServiceServer) TerminateVM(context.Context, *TerminateVMRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateVM not implemented")
}
func (UnimplementedVMServiceServer) ConnectVM(context.Context, *ConnectVMRequest) (*ConnectVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectVM not implemented")
}
func (UnimplementedVMServiceServer) ResizeVM(context.Context, *ResizeVMRequest) (*ResizeVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResizeVM not implemented")
}
func (UnimplementedVMServiceServer) ListPublicVMImages(context.Context, *ListPublicVMImagesRequest) (*ListPublicVMImagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPublicVMImages not implemented")
}
func (UnimplementedVMServiceServer) ListVMMachineTypes(context.Context, *ListVMMachineTypesRequest) (*ListVMMachineTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMMachineTypes not implemented")
}
func (UnimplementedVMServiceServer) ListVMMachineTypes2(context.Context, *ListVMMachineTypesRequest) (*ListVMMachineTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMMachineTypes2 not implemented")
}
func (UnimplementedVMServiceServer) ListVMDataCenters(context.Context, *ListVMDataCentersRequest) (*ListVMDataCentersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMDataCenters not implemented")
}
func (UnimplementedVMServiceServer) ListVMGpuModels(context.Context, *ListVMGpuModelsRequest) (*ListVMGpuModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMGpuModels not implemented")
}
func (UnimplementedVMServiceServer) CreatePrivateVMImage(context.Context, *CreatePrivateVMImageRequest) (*CreatePrivateVMImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePrivateVMImage not implemented")
}
func (UnimplementedVMServiceServer) DeletePrivateVMImage(context.Context, *DeletePrivateVMImageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePrivateVMImage not implemented")
}
func (UnimplementedVMServiceServer) GetPrivateVMImage(context.Context, *GetPrivateVMImageRequest) (*GetPrivateVMImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrivateVMImage not implemented")
}
func (UnimplementedVMServiceServer) ListPrivateVMImages(context.Context, *ListPrivateVMImagesRequest) (*ListPrivateVMImagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPrivateVMImages not implemented")
}
func (UnimplementedVMServiceServer) UpdatePrivateVMImage(context.Context, *UpdatePrivateVMImageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrivateVMImage not implemented")
}
func (UnimplementedVMServiceServer) CreateStorageDisk(context.Context, *CreateStorageDiskRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStorageDisk not implemented")
}
func (UnimplementedVMServiceServer) ResizeVMDisk(context.Context, *ResizeVMDiskRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResizeVMDisk not implemented")
}
func (UnimplementedVMServiceServer) ListDisks(context.Context, *ListDisksRequest) (*ListDisksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDisks not implemented")
}
func (UnimplementedVMServiceServer) GetDisk(context.Context, *GetDiskRequest) (*GetDiskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDisk not implemented")
}
func (UnimplementedVMServiceServer) DeleteStorageDisk(context.Context, *DeleteStorageDiskRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStorageDisk not implemented")
}
func (UnimplementedVMServiceServer) AttachStorageDisk(context.Context, *AttachStorageDiskRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachStorageDisk not implemented")
}
func (UnimplementedVMServiceServer) DetachStorageDisk(context.Context, *DetachStorageDiskRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachStorageDisk not implemented")
}
func (UnimplementedVMServiceServer) AttachSecurityGroup(context.Context, *AttachSecurityGroupRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachSecurityGroup not implemented")
}
func (UnimplementedVMServiceServer) DetachSecurityGroup(context.Context, *DetachSecurityGroupRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachSecurityGroup not implemented")
}
func (UnimplementedVMServiceServer) UpdateVMMetadata(context.Context, *UpdateVMMetadataRequest) (*UpdateVMMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVMMetadata not implemented")
}
func (UnimplementedVMServiceServer) UpdateVMExpireTime(context.Context, *UpdateVMExpireTimeRequest) (*UpdateVMExpireTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVMExpireTime not implemented")
}
func (UnimplementedVMServiceServer) UpdateVMPassword(context.Context, *UpdateVMPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVMPassword not implemented")
}
func (UnimplementedVMServiceServer) UpdateVMAuthorizedSSHKeys(context.Context, *UpdateVMAuthorizedSSHKeysRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVMAuthorizedSSHKeys not implemented")
}
func (UnimplementedVMServiceServer) CommitVM(context.Context, *CommitVMRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitVM not implemented")
}
func (UnimplementedVMServiceServer) GetVMMachineType(context.Context, *GetVMMachineTypeRequest) (*GetVMMachineTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMachineType not implemented")
}
func (UnimplementedVMServiceServer) mustEmbedUnimplementedVMServiceServer() {}
func (UnimplementedVMServiceServer) testEmbeddedByValue()                   {}

// UnsafeVMServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VMServiceServer will
// result in compilation errors.
type UnsafeVMServiceServer interface {
	mustEmbedUnimplementedVMServiceServer()
}

func RegisterVMServiceServer(s grpc.ServiceRegistrar, srv VMServiceServer) {
	// If the following call pancis, it indicates UnimplementedVMServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VMService_ServiceDesc, srv)
}

func _VMService_CountVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CountVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CountVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CountVMs(ctx, req.(*CountVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CreateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreateVM(ctx, req.(*CreateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetVM(ctx, req.(*GetVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMs(ctx, req.(*ListVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_MonitorVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MonitorVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).MonitorVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_MonitorVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).MonitorVM(ctx, req.(*MonitorVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_RebootVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).RebootVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_RebootVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).RebootVM(ctx, req.(*RebootVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StartVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).StartVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_StartVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).StartVM(ctx, req.(*StartVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StopVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).StopVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_StopVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).StopVM(ctx, req.(*StopVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_TerminateVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).TerminateVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_TerminateVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).TerminateVM(ctx, req.(*TerminateVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ConnectVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ConnectVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ConnectVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ConnectVM(ctx, req.(*ConnectVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ResizeVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ResizeVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ResizeVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ResizeVM(ctx, req.(*ResizeVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListPublicVMImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPublicVMImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListPublicVMImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListPublicVMImages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListPublicVMImages(ctx, req.(*ListPublicVMImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMMachineTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMMachineTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMMachineTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMMachineTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMMachineTypes(ctx, req.(*ListVMMachineTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMMachineTypes2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMMachineTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMMachineTypes2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMMachineTypes2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMMachineTypes2(ctx, req.(*ListVMMachineTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMDataCenters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMDataCentersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMDataCenters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMDataCenters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMDataCenters(ctx, req.(*ListVMDataCentersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListVMGpuModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMGpuModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVMGpuModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVMGpuModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVMGpuModels(ctx, req.(*ListVMGpuModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CreatePrivateVMImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePrivateVMImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreatePrivateVMImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreatePrivateVMImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreatePrivateVMImage(ctx, req.(*CreatePrivateVMImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DeletePrivateVMImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePrivateVMImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DeletePrivateVMImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DeletePrivateVMImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DeletePrivateVMImage(ctx, req.(*DeletePrivateVMImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetPrivateVMImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivateVMImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetPrivateVMImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetPrivateVMImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetPrivateVMImage(ctx, req.(*GetPrivateVMImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListPrivateVMImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrivateVMImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListPrivateVMImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListPrivateVMImages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListPrivateVMImages(ctx, req.(*ListPrivateVMImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_UpdatePrivateVMImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePrivateVMImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).UpdatePrivateVMImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_UpdatePrivateVMImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).UpdatePrivateVMImage(ctx, req.(*UpdatePrivateVMImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CreateStorageDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStorageDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreateStorageDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreateStorageDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreateStorageDisk(ctx, req.(*CreateStorageDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ResizeVMDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeVMDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ResizeVMDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ResizeVMDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ResizeVMDisk(ctx, req.(*ResizeVMDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ListDisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListDisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListDisks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListDisks(ctx, req.(*ListDisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetDisk(ctx, req.(*GetDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DeleteStorageDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStorageDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DeleteStorageDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DeleteStorageDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DeleteStorageDisk(ctx, req.(*DeleteStorageDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_AttachStorageDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachStorageDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).AttachStorageDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_AttachStorageDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).AttachStorageDisk(ctx, req.(*AttachStorageDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DetachStorageDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachStorageDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DetachStorageDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DetachStorageDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DetachStorageDisk(ctx, req.(*DetachStorageDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_AttachSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachSecurityGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).AttachSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_AttachSecurityGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).AttachSecurityGroup(ctx, req.(*AttachSecurityGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DetachSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachSecurityGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DetachSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DetachSecurityGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DetachSecurityGroup(ctx, req.(*DetachSecurityGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_UpdateVMMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVMMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).UpdateVMMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_UpdateVMMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).UpdateVMMetadata(ctx, req.(*UpdateVMMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_UpdateVMExpireTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVMExpireTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).UpdateVMExpireTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_UpdateVMExpireTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).UpdateVMExpireTime(ctx, req.(*UpdateVMExpireTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_UpdateVMPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVMPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).UpdateVMPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_UpdateVMPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).UpdateVMPassword(ctx, req.(*UpdateVMPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_UpdateVMAuthorizedSSHKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVMAuthorizedSSHKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).UpdateVMAuthorizedSSHKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_UpdateVMAuthorizedSSHKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).UpdateVMAuthorizedSSHKeys(ctx, req.(*UpdateVMAuthorizedSSHKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_CommitVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CommitVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CommitVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CommitVM(ctx, req.(*CommitVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetVMMachineType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMMachineTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetVMMachineType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetVMMachineType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetVMMachineType(ctx, req.(*GetVMMachineTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VMService_ServiceDesc is the grpc.ServiceDesc for VMService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VMService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "org.cudo.compute.v1.VMService",
	HandlerType: (*VMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CountVMs",
			Handler:    _VMService_CountVMs_Handler,
		},
		{
			MethodName: "CreateVM",
			Handler:    _VMService_CreateVM_Handler,
		},
		{
			MethodName: "GetVM",
			Handler:    _VMService_GetVM_Handler,
		},
		{
			MethodName: "ListVMs",
			Handler:    _VMService_ListVMs_Handler,
		},
		{
			MethodName: "MonitorVM",
			Handler:    _VMService_MonitorVM_Handler,
		},
		{
			MethodName: "RebootVM",
			Handler:    _VMService_RebootVM_Handler,
		},
		{
			MethodName: "StartVM",
			Handler:    _VMService_StartVM_Handler,
		},
		{
			MethodName: "StopVM",
			Handler:    _VMService_StopVM_Handler,
		},
		{
			MethodName: "TerminateVM",
			Handler:    _VMService_TerminateVM_Handler,
		},
		{
			MethodName: "ConnectVM",
			Handler:    _VMService_ConnectVM_Handler,
		},
		{
			MethodName: "ResizeVM",
			Handler:    _VMService_ResizeVM_Handler,
		},
		{
			MethodName: "ListPublicVMImages",
			Handler:    _VMService_ListPublicVMImages_Handler,
		},
		{
			MethodName: "ListVMMachineTypes",
			Handler:    _VMService_ListVMMachineTypes_Handler,
		},
		{
			MethodName: "ListVMMachineTypes2",
			Handler:    _VMService_ListVMMachineTypes2_Handler,
		},
		{
			MethodName: "ListVMDataCenters",
			Handler:    _VMService_ListVMDataCenters_Handler,
		},
		{
			MethodName: "ListVMGpuModels",
			Handler:    _VMService_ListVMGpuModels_Handler,
		},
		{
			MethodName: "CreatePrivateVMImage",
			Handler:    _VMService_CreatePrivateVMImage_Handler,
		},
		{
			MethodName: "DeletePrivateVMImage",
			Handler:    _VMService_DeletePrivateVMImage_Handler,
		},
		{
			MethodName: "GetPrivateVMImage",
			Handler:    _VMService_GetPrivateVMImage_Handler,
		},
		{
			MethodName: "ListPrivateVMImages",
			Handler:    _VMService_ListPrivateVMImages_Handler,
		},
		{
			MethodName: "UpdatePrivateVMImage",
			Handler:    _VMService_UpdatePrivateVMImage_Handler,
		},
		{
			MethodName: "CreateStorageDisk",
			Handler:    _VMService_CreateStorageDisk_Handler,
		},
		{
			MethodName: "ResizeVMDisk",
			Handler:    _VMService_ResizeVMDisk_Handler,
		},
		{
			MethodName: "ListDisks",
			Handler:    _VMService_ListDisks_Handler,
		},
		{
			MethodName: "GetDisk",
			Handler:    _VMService_GetDisk_Handler,
		},
		{
			MethodName: "DeleteStorageDisk",
			Handler:    _VMService_DeleteStorageDisk_Handler,
		},
		{
			MethodName: "AttachStorageDisk",
			Handler:    _VMService_AttachStorageDisk_Handler,
		},
		{
			MethodName: "DetachStorageDisk",
			Handler:    _VMService_DetachStorageDisk_Handler,
		},
		{
			MethodName: "AttachSecurityGroup",
			Handler:    _VMService_AttachSecurityGroup_Handler,
		},
		{
			MethodName: "DetachSecurityGroup",
			Handler:    _VMService_DetachSecurityGroup_Handler,
		},
		{
			MethodName: "UpdateVMMetadata",
			Handler:    _VMService_UpdateVMMetadata_Handler,
		},
		{
			MethodName: "UpdateVMExpireTime",
			Handler:    _VMService_UpdateVMExpireTime_Handler,
		},
		{
			MethodName: "UpdateVMPassword",
			Handler:    _VMService_UpdateVMPassword_Handler,
		},
		{
			MethodName: "UpdateVMAuthorizedSSHKeys",
			Handler:    _VMService_UpdateVMAuthorizedSSHKeys_Handler,
		},
		{
			MethodName: "CommitVM",
			Handler:    _VMService_CommitVM_Handler,
		},
		{
			MethodName: "GetVMMachineType",
			Handler:    _VMService_GetVMMachineType_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "svc/compute/vm/vm_svc.proto",
}
